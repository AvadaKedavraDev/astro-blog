---
// 文件名: src/pages/blog/[slug].astro
import ArticleLayout from "@/layouts/ArticleLayout.astro";
import { getCollection } from "astro:content";
import type { InferGetStaticPropsType } from "astro";

// 定义一个简化类型用于导航链接
type NavPost = {
    slug: string;
    title: string;
} | undefined;

export async function getStaticPaths() {
    // 1. 获取所有博客文章
    const blogPosts = await getCollection("blog");
    
    // 2. (可选但推荐) 对文章进行排序
    // 假设您希望按发布日期降序排列 (最新的在前)
    // 如果不排序，相邻文章的顺序将取决于文件系统或 Astro 的默认加载顺序
    const sortedPosts = blogPosts.sort(
        (a, b) => b.data.pubDate.getTime() - a.data.pubDate.getTime()
    );

    return sortedPosts.map((post, index) => {
        // 3. 确定上一篇 (Prev) 和下一篇 (Next)
        // console.log(`Processing post:{post}`,post,index);
        // Prev: 索引比当前文章大 1 (因为我们是降序排列，数组中索引越大日期越旧)
        // 注意：如果 sortedPosts[index + 1] 存在，它就是时间上更旧的文章
        const prevPost = sortedPosts[index + 1];
        
        // Next: 索引比当前文章小 1 (索引为 0 时没有 Next)
        // 注意：如果 sortedPosts[index - 1] 存在，它就是时间上更新的文章
        const nextPost = sortedPosts[index - 1];
        
        // 4. 构建导航数据对象
        const prev: NavPost = prevPost
            ? { slug: prevPost.slug, title: prevPost.data.title }
            : undefined;
            
        const next: NavPost = nextPost
            ? { slug: nextPost.slug, title: nextPost.data.title }
            : undefined;

        // 5. 将导航数据作为 props 传递
        return {
            params: { slug: post.slug },
            props: { post, prev, next },
        };
    });
}

// 现在 Props 会被 InferGetStaticPropsType 自动推断为包含 post, prev, next
type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { post, prev, next } = Astro.props; // 解构出 prev 和 next
const { Content } = await post.render();
const { title } = post.data;

---

<ArticleLayout title="" next={next} prev={prev}>
    <h1>{title}</h1>
    <Content />
</ArticleLayout>
