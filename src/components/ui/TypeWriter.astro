---
/**
 * @description 打字机动效组件，逐字显示文本
 * @props text - 要显示的文本
 * @props class - 自定义类名
 * @props speed - 打字速度（默认100ms）
 * @props delay - 延迟开始时间（默认500ms）
 * @features 字符级动画、Swup 兼容、防止重复初始化
 * @usage 用于首页标题等需要打字效果的场景
 */
// 打字机组件
interface Props {
    text: string;
    class?: string;
    speed?: number;
    delay?: number;
}

const {text, class: className = '', speed = 100, delay = 500} = Astro.props;
const uid = Math.random().toString(36).substring(2, 11);
---

<span
        id={`tw-${uid}`}
        class={`type-writer ${className}`}
        data-text={text}
        data-speed={speed}
        data-delay={delay}
        data-uid={uid}
>
  <span class="type-text"></span>
  <span class="cursor">|</span>
</span>

<style>
    .type-writer {
        display: inline;
    }

    .cursor {
        animation: blink 1s step-end infinite;
        display: inline-block;
    }

    @keyframes blink {
        0%, 100% {
            opacity: 1;
        }
        50% {
            opacity: 0;
        }
    }

    .cursor.typing {
        animation: none;
        opacity: 1;
    }

    .cursor.finished {
        animation: blink 1.5s step-end infinite;
    }
</style>

<script>
    // 先定义 TypeWriter 类，再声明全局类型
    class TypeWriter {
        element: HTMLElement;
        uid: string = '';
        text: string = '';
        speed: number = 100;
        delay: number = 500;
        textEl: HTMLElement | null = null;
        cursorEl: HTMLElement | null = null;
        timeouts: number[] = [];
        dead: boolean = false;

        constructor(element: HTMLElement) {
            this.element = element;
            this.uid = element.dataset.uid || '';
            this.text = element.dataset.text || '';
            this.speed = parseInt(element.dataset.speed || '100');
            this.delay = parseInt(element.dataset.delay || '500');
            this.textEl = element.querySelector('.type-text');
            this.cursorEl = element.querySelector('.cursor');

            // 防止重复初始化
            if (element.dataset.initialized === 'true') {
                return;
            }
            element.dataset.initialized = 'true';

            // 清理同 ID 旧实例
            if (window.__TW_GLOBAL?.instances.has(this.uid)) {
                window.__TW_GLOBAL.instances.get(this.uid)?.kill();
            }

            window.__TW_GLOBAL?.instances.set(this.uid, this);
            this.start();
        }

        async start(): Promise<void> {
            await this.wait(this.delay + 300);

            if (this.dead) return;

            this.cursorEl?.classList.add('typing');

            for (let i = 0; i < this.text.length; i++) {
                if (this.dead) break;

                if (this.textEl) {
                    this.textEl.textContent += this.text.charAt(i);
                }
                await this.wait(this.speed);
            }

            if (!this.dead) {
                this.cursorEl?.classList.remove('typing');
                this.cursorEl?.classList.add('finished');
            }
        }

        wait(ms: number): Promise<void> {
            return new Promise((resolve) => {
                const t = window.setTimeout(() => {
                    resolve();
                }, ms);
                this.timeouts.push(t);
                window.__TW_GLOBAL?.timeouts.add(t);
            });
        }

        kill(): void {
            this.dead = true;
            this.timeouts.forEach(t => {
                clearTimeout(t);
                window.__TW_GLOBAL?.timeouts.delete(t);
            });
            this.timeouts = [];

            if (this.textEl) {
                this.textEl.textContent = '';
                this.textEl.innerHTML = '';
            }
            if (this.cursorEl) {
                this.cursorEl.className = 'cursor';
            }

            window.__TW_GLOBAL?.instances.delete(this.uid);
        }
    }

    // 全局类型声明放在类定义之后
    declare global {
        interface Window {
            __TW_GLOBAL?: {
                instances: Map<string, InstanceType<typeof TypeWriter>>;
                timeouts: Set<number>;
                observer: MutationObserver | null;
                isCleaning: boolean;
                reinitTimer?: number;
            };
            fixTypewriter?: () => void;
            SwupCompat?: {
                onPageView: (callback: () => void) => () => void;
                onContentReplace: (callback: () => void) => () => void;
                beforeContentReplace: (callback: () => void) => () => void;
            };
            swup?: {
                hooks?: {
                    on: (event: string, callback: () => void) => void;
                    off: (event: string, callback: () => void) => void;
                };
                options?: {
                    cache?: boolean;
                };
            };
        }
    }

    (function () {
        'use strict';

        // 初始化全局状态
        if (!window.__TW_GLOBAL) {
            window.__TW_GLOBAL = {
                instances: new Map(),
                timeouts: new Set(),
                observer: null,
                isCleaning: false
            };
        }

        const G = window.__TW_GLOBAL;

        // 强制清理所有打字机
        function nukeAllTypewriters(): void {
            if (G.isCleaning) return;
            G.isCleaning = true;

            // 销毁所有实例
            G.instances.forEach((inst) => {
                try {
                    inst.kill();
                } catch (e) {
                    // 忽略销毁错误
                }
            });
            G.instances.clear();

            // 清除所有定时器
            G.timeouts.forEach(id => clearTimeout(id));
            G.timeouts.clear();

            // 重置所有 DOM 元素
            document.querySelectorAll('.type-writer').forEach(el => {
                const textEl = el.querySelector('.type-text');
                const cursorEl = el.querySelector('.cursor');
                if (textEl) {
                    textEl.textContent = '';
                    (textEl as HTMLElement).innerHTML = '';
                }
                if (cursorEl) {
                    cursorEl.className = 'cursor';
                    (cursorEl as HTMLElement).style.cssText = '';
                }
                el.removeAttribute('data-initialized');
            });

            window.setTimeout(() => {
                G.isCleaning = false;
            }, 50);
        }

        // 初始化函数
        function init(): void {
            nukeAllTypewriters();

            const t = window.setTimeout(() => {
                document.querySelectorAll('.type-writer:not([data-initialized])').forEach(el => {
                    new TypeWriter(el as HTMLElement);
                });
            }, 100);
            G.timeouts.add(t);
        }

        // 使用 SwupCompat 统一处理（如果可用）
        function bindWithSwupCompat(): boolean {
            if (window.SwupCompat) {
                window.SwupCompat.beforeContentReplace(nukeAllTypewriters);
                window.SwupCompat.onPageView(init);
                return true;
            }
            return false;
        }

        // 直接绑定 Swup hooks（备用方案）
        function bindSwupHooks(): boolean {
            if (window.swup && window.swup.hooks) {
                // 注意：先解绑再绑定，避免重复
                window.swup.hooks.off('content:replace', nukeAllTypewriters);
                window.swup.hooks.off('page:view', init);
                window.swup.hooks.on('content:replace', nukeAllTypewriters);
                window.swup.hooks.on('page:view', init);
                return true;
            }
            return false;
        }

        // 标准事件（兼容旧版 Swup）
        document.addEventListener('swup:contentReplaced', () => {
            nukeAllTypewriters();
            init();
        });
        document.addEventListener('swup:beforeContentReplace', nukeAllTypewriters);
        
        // Astro View Transitions 兼容
        document.addEventListener('astro:page-load', () => {
            nukeAllTypewriters();
            init();
        });

        // 延迟绑定（等待 SwupCompat 或 Swup 加载）
        if (!bindWithSwupCompat()) {
            const checkInterval = window.setInterval(() => {
                if (bindWithSwupCompat() || bindSwupHooks()) {
                    clearInterval(checkInterval);
                }
            }, 100);
            G.timeouts.add(checkInterval);

            // 10秒后停止检查
            window.setTimeout(() => {
                clearInterval(checkInterval);
            }, 10000);
        }

        // MutationObserver 监视 DOM 变化
        if (!G.observer) {
            G.observer = new MutationObserver((mutations) => {
                let shouldReinit = false;

                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) {
                            const el = node as HTMLElement;
                            if (el.classList?.contains('type-writer') ||
                                el.querySelector?.('.type-writer')) {
                                shouldReinit = true;
                            }
                        }
                    });
                });

                if (shouldReinit && !G.isCleaning) {
                    clearTimeout(G.reinitTimer);
                    G.reinitTimer = window.setTimeout(init, 50);
                }
            });

            G.observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        }

        // 首次加载
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // 暴露全局清理函数
        window.fixTypewriter = nukeAllTypewriters;

    })();
</script>