---
/**
 * @component SwupCompat
 * @description Swup 兼容性工具组件，提供统一的生命周期事件管理
 * @features onPageView、onContentReplace、beforeContentReplace API
 * @usage 在 BaseLayout 中引用，其他组件通过 window.SwupCompat 访问
 */
---

<script is:inline>
// @ts-nocheck - 这是一个纯 JavaScript 文件，禁用 TypeScript 检查
(function() {
  'use strict';
  
  // 如果已经存在且已就绪，直接返回
  if (window.SwupCompat && window.SwupCompat.__isReady__) {
    return;
  }
  
  // 保留已有的回调（如果存在）
  const existingCallbacks = window.SwupCompat?.callbacks || {
    'page:view': [],
    'content:replace': [],
    'content:replace:before': []
  };
  
  // 创建全局 Swup 兼容管理器
  window.SwupCompat = {
    // 回调注册表（保留已有的）
    callbacks: {
      'page:view': [...existingCallbacks['page:view']],
      'content:replace': [...existingCallbacks['content:replace']],
      'content:replace:before': [...existingCallbacks['content:replace:before']]
    },
    
    // 是否已初始化事件监听
    __isReady__: false,
    
    // 注册页面视图回调（页面切换完成后）
    onPageView(callback, options = {}) {
      const { immediate = true } = options;
      
      // 添加到注册表
      this.callbacks['page:view'].push(callback);
      
      // 立即执行一次（如果页面已加载）
      if (immediate && document.readyState !== 'loading') {
        try {
          callback();
        } catch (e) {
          console.error('SwupCompat: 初始回调执行失败:', e);
        }
      }
      
      return () => this.off('page:view', callback);
    },
    
    // 注册内容替换后回调
    onContentReplace(callback, options = {}) {
      const { immediate = true } = options;
      
      this.callbacks['content:replace'].push(callback);
      
      if (immediate && document.readyState !== 'loading') {
        try {
          callback();
        } catch (e) {
          console.error('SwupCompat: 初始回调执行失败:', e);
        }
      }
      
      return () => this.off('content:replace', callback);
    },
    
    // 注册内容替换前回调
    beforeContentReplace(callback) {
      this.callbacks['content:replace:before'].push(callback);
      return () => this.off('content:replace:before', callback);
    },
    
    // 移除回调
    off(event, callback) {
      if (this.callbacks[event]) {
        const index = this.callbacks[event].indexOf(callback);
        if (index > -1) {
          this.callbacks[event].splice(index, 1);
        }
      }
    },
    
    // 触发回调
    emit(event) {
      if (this.callbacks[event]) {
        this.callbacks[event].forEach(callback => {
          try {
            callback();
          } catch (e) {
            console.error(`SwupCompat: ${event} 回调执行失败:`, e);
          }
        });
      }
    },
    
    // 手动触发 Swup Scripts Plugin
    runScripts() {
      const scriptsPlugin = window.swup?.findPlugin('SwupScriptsPlugin');
      if (scriptsPlugin && scriptsPlugin.runScripts) {
        console.log('[SwupCompat] Manually triggering runScripts');
        // 使用 call 绑定 this，确保方法内部能正确访问 this.options 和 this.swup
        scriptsPlugin.runScripts.call(scriptsPlugin);
      }
    },
    
    // 清理动态添加的内容（在 Swup 导航前调用）
    cleanup() {
      // 清理 rehype-code-group 的初始化标记
      document.querySelectorAll('.rehype-code-group[data-swup-compat-initialized]').forEach((group) => {
        delete group.dataset.swupCompatInitialized;
      });
      
      // 清理 KaTeX 可能的问题（如果有客户端脚本）
      // 注意：KaTeX 是服务端渲染的，通常不需要清理，但这里做保险处理
    },
    
    // 初始化 rehype-code-group 代码块多标签切换
    initCodeGroups() {
      const codeGroups = document.querySelectorAll('.rehype-code-group');
      if (codeGroups.length === 0) return;
      
      codeGroups.forEach((group) => {
        // 跳过已初始化的组（防止重复绑定）
        if (group.dataset.swupCompatInitialized) return;
        
        const tabs = group.querySelectorAll('.rcg-tab');
        const blocks = group.querySelectorAll('.rcg-block');
        
        if (tabs.length === 0 || blocks.length === 0) return;
        
        // 标记为已初始化
        group.dataset.swupCompatInitialized = 'true';
        
        // 获取当前激活状态
        let activeTab = group.querySelector('.rcg-tab.active');
        let activeBlock = group.querySelector('.rcg-block.active');
        
        // 添加点击事件监听
        group.addEventListener('click', (event) => {
          const tab = event.target.closest('.rcg-tab');
          if (!tab) return;
          
          const index = Array.from(tabs).indexOf(tab);
          if (index === -1) return;
          
          // 移除当前激活状态
          if (activeTab) {
            activeTab.classList.remove('active');
            activeTab.setAttribute('aria-selected', 'false');
          }
          if (activeBlock) {
            activeBlock.classList.remove('active');
            activeBlock.setAttribute('hidden', 'true');
          }
          
          // 激活新标签
          tab.classList.add('active');
          tab.setAttribute('aria-selected', 'true');
          
          const newBlock = blocks[index];
          if (newBlock) {
            newBlock.classList.add('active');
            newBlock.removeAttribute('hidden');
          }
          
          // 更新激活状态引用
          activeTab = tab;
          activeBlock = newBlock;
        });
      });
      
      if (codeGroups.length > 0) {
        console.log('[SwupCompat] Initialized rehype-code-group:', codeGroups.length, 'groups');
      }
    },
    
    // 初始化事件监听
    init() {
      if (this.__isReady__) return;
      
      // 标记是否使用新版 hooks，避免重复触发
      let usingNewHooks = false;
      
      // 监听 Swup 标准事件（旧版兼容）- 仅当新版 hooks 不可用时使用
      document.addEventListener('swup:contentReplaced', () => {
        if (usingNewHooks) return; // 如果已使用新版 hooks，跳过旧版事件
        this.emit('content:replace');
        this.runScripts(); // 手动触发脚本执行
        this.initCodeGroups(); // 初始化 rehype-code-group
        requestAnimationFrame(() => {
          setTimeout(() => this.emit('page:view'), 0);
        });
      });
      
      document.addEventListener('swup:beforeContentReplace', () => {
        if (usingNewHooks) return;
        this.emit('content:replace:before');
        this.cleanup(); // 清理动态内容
      });
      
      // 监听 Swup hooks（新版）
      const bindSwupHooks = () => {
        if (window.swup?.hooks) {
          console.log('[SwupCompat] Binding to swup hooks');
          usingNewHooks = true; // 标记使用新版 hooks
          
          window.swup.hooks.on('content:replace', () => {
            this.emit('content:replace:before');
            this.cleanup(); // 清理动态内容
          });
          
          window.swup.hooks.on('content:replace', () => {
            this.emit('content:replace');
            this.runScripts(); // 手动触发脚本执行
            this.initCodeGroups(); // 初始化 rehype-code-group
          });
          
          window.swup.hooks.on('page:view', () => {
            this.emit('page:view');
          });
          
          return true;
        }
        return false;
      };
      
      if (!bindSwupHooks()) {
        document.addEventListener('swup:enable', () => {
          bindSwupHooks();
        }, { once: true });
      }
      
      document.addEventListener('astro:page-load', () => {
        this.emit('page:view');
        this.initCodeGroups(); // 初始化 rehype-code-group
      });
      
      // 初始页面加载时也执行
      if (document.readyState !== 'loading') {
        this.initCodeGroups();
      } else {
        document.addEventListener('DOMContentLoaded', () => this.initCodeGroups());
      }
      
      this.__isReady__ = true;
    }
  };
  
  // 立即初始化
  window.SwupCompat.init();
})();
</script>
